Сделать любой алгоритм поиска оптимального пути. По запускать его из разных мест по всей карте, запомнить часто используемые узлы (перекрестки) и использовать их потом в комбинации с обычным алгоритмом.
Сделать возможность отмечать предпочтительные/нежелательные для проезда зоны/дороги.

Тонкая настройка приоритета разных видов дорог. И видов их пересечения.

Возможно удобно иметь несколько масштабов на экране одновременно.

Не только включение обязательных точек в маршрут, но и исключение запрещенных.

Учет истории при прокладывании маршрута.

учет дополнительных условий, например минимизировать количество перекрестков/поворотов или минимизировать количество поворотов налево не перекрестках.


//-----------------------------------------------------------------------------------------------------------------

Простраиваем [кратчайшие/все возможные/лучшие N/все не сильно отличающиеся от оптимального] маршруты от [одних случайных/каждого] [точек/тупиков/перекрестков] до [случайных/всех] других пока [не останется не посещенных [точек/тупиков/перекрестков]/не переберем все/не надоест]

Используемость пути:
[Минимальное|Медианное|Среднее|Максимальное при прохождении в сторону где минимум (для каждого пути запоминаем максимум в каждую сторону и потом берем меньший посчитанный из них)] количество километров до которых обязательно дойдет алгоритм волновой трассировки, пока не упрется в тупики [или в уже пройденные точки с меньшим расстоянием от эпицентра], после прохождения пути. Для получения наиболее верных значений трассировку надо запускать издалека и со стороны где больше узлов.
1) Запускаем алгоритм Дейкстры от случайной точки и помечаем для каждого узла его расстояние до эпицентра.
2) От каждого узла идем к эпицентру по волновым отметкам, по ходу помечая пути как посчитанные и суммы не посчитанных путей добавляем к используемости следующего пути.
Проблема: наибольшее использование получат тупо те узлы, которые в середине карты - от них и вправо и влево по пол карты дорог, а вовсе не самые незаменимые.
Решение: можно медиану разницы с соседями брать, её-то и использовать.
Проблема: объезды участков дорог (например городов) выпадают из анализа.
Решение: не такая уж и проблема - мы же ищем ключевые узлы, а не наилучший маршрут. А начало и конец объезда как раз могут оказаться ключевыми точками.



Выбираем некоторое количество самых используемых точек. - это будут базовые узловые точки. 
Как только ни к одной из узловых точек нельзя подойти с разных сторон не проходя через другую узловую точку - считаем, что подготовка завершена.
Далее добавляем постепенно еще точки из менее используемых так, чтобы как можно быстрее закончить подготовку:
      запускаем от узла маршрут в одну сторону и если он вернулся с другой стороны, то

	*       самую используемую точку на маршруте добавляем к базовым базу.
	* или идем от нашей точки по этой петле и ищем другой наибольший локальный максимум, не являющийся частью того же максимума, что и проверяемая точка
	* 
		* если другого максимума нет - берем середину петли
По этим базовым точкам сохраняем информацию о расстояниях и маршрутах между ними. При поиске конкретного маршрута если упираемся в базовую точку, то ищем в других направлениях. Если по всем направлениям базовые точки, то используем таблицу. Т.о. путь может состоять из 3-х частей: путь от старта до стартовой базовой точки, путь от стартовой базовой точки до базовой финишной точки, путь от базовой финишной точки до финиша. В идеале сложность поиска по каждой из частей должна быть примерно одинакова.

//-----------------------------------------------------------------------------------------------------------------

Базовые точки д.б. расположены так, чтобы минимизировать количество количество перекрестков до которых можно добраться без использования базовых точек.
Нужно попробовать прикрутить некий нечеткий алгоритм ИИ, который бы подобрал достаточно хорошие базовые точки.
Генерируем набор, считаем качество, генерируем еще.
Похоже на генетический алгоритм:
Генерируем популяцию наборов из K точек. Выбираем лучшие. Скрещиваем. Генерируем еще.

Набор: 
- set из К неповторяющихся узлов.
- набор пар узлов. Между узлами в паре строится кратчайший путь и все узлы пути добавляются в набор K.
- в разрез добаляется вся граница карты. Каждый конечный узел каждого разреза должен быть на каком-либо другом разрезе
хотябы один узел должен быть на границе карты, конечный узел должен быть на другом пути

Разделяем карту на N частей и постепенно выравниваем эти части по площади.
разрез не может соприкасаться с разрезом кроме как конечной точкой.
разрез может состоять из одной точки
Необходимо понятие слева от разреза и справа от разреза на стыках с другими разрезами: слева - слева от первой точки разреза, справа от последней; справа - справа от первой точки разреза, слева от последней
Кроме того нужно минимизировать количество точек в разрезах. Это можно сделать после выравнивания по площади.


делим карту пополам, потом каждую из частей пополам и т.д.


Скрещивание: берем половину от одного, половину от другого. Повторяющиеся вычеркиваются. Недостающие дополняем случайными. // скрещивание двух жизнеспособных скорее всего создаст нежизнеспособного
Оценка приспособленности: из нескольких точек делаем заливку пока не упрется в тупики или базовые точки. приспособленность обратно пропорциональна максимальной площади заливки.


Из одной области в другую соседнюю можно попадать только одним путем и этот путь должен быть кратчайшим из этой области в любую точку в соседней.

//-----------------------------------------------------------------------------------------------------------------

Избегание тупиков: При работе алгоритма Дейкстры можно использовать метки на way, в которых указано максимальное геометрически расстояние на которое можно уйти за этим way в эту сторону и если оно меньше, чем геометрическое расстояние до цели, то не заходим в этот way

Можно попробовать носорожий алгоритм с промежуточными оптимизациями.

//-----------------------------------------------------------------------------------------------------------------

Для вычеркивания заранее неподходящих путей пригодились бы данные о соотношении (минимальная длина пути/геометрическое расстояние) для нескольких диапазонов расстояний.

//-----------------------------------------------------------------------------------------------------------------

Так как скорее всего будет использоваться взвешивание типов дорог, то при наличии даже очень коротких отрезков пути низкого класса надо предупреждать о них пользователя. Вдруг были сильные дожди и любые грунтовые дороги теперь составляют проблему.

Предупреждать о резком повороте впереди (хотя бы только при высокой скорости)


Карту показывать как проекцию сферы на плоскость, центр сферы всегда на оси центра экрана, на расстоянии одного радиуса от экрана. Масштабирование - изменение радиуса сферы.

//-----------------------------------------------------------------------------------------------------------------

Большие карты: http://download.geofabrik.de/

Оптимизиция
http://habrahabr.ru/post/190850/

//---------------------------------------------------------------------------------------


На каждом перекрестке выбирать поворот на тот путь, по которому поиском в ширину можно как можно геометрически ближе подойти к цели через максимум N километров
или
На каждом перекрестке выбирать поворот на тот путь, выход которого геометрически ближе к цели
или
На каждом перекрестке выбирать поворот на тот путь, единичный вектор вдоль которого геометрически ближе всего к цели

Работать должно довольно быстро, хоть путь и далеко не оптимальный. 

Можно улучшить путь, повторив алгоритм для промежуточных отрезков пути, особенно там, где большое отношение длины пути к дистанции между точками.
А если расстояние между точками не очень большое можно и хороший-медленный алгоритм применить для оптимизации.
  
Можно использовать как верхнюю границу длины пути для других алгоритмов.

//---------------------------------------------------------------------------------------

Поиск кратчайшего маршрута на дорожной карте:

В множество текущих точек добавляем стартовую точку.
МаксимальноеРасстояние = бесконечность
ТекущаяСледующаяТочка = пусто

Цикл
  Для каждой точки из текущих точек
    МинимальноеРасстояние = бесконечность
    ТекущаяСледующаяТочка = пусто
    Если у текущей точки есть не посещенные соседние точки, то
      Для каждой соседней точки текущей точки
        СледТочка = текущая соседняя точка
        Расстояние = ДлинаПути(Старт, ТекТочка) + ДлинаПути(СледТочка, ТекТочка) + Дистанция(СледТочка, КонечТочка)
        Если МаксимальноеРасстояние > Расстояние то
          Если Расстояние < МинимальноеРасстояние То 
            ТекущаяСледующаяТочка = СледТочка
            МинимальноеРасстояние = Расстояние
    Если ТекущаяСледующаяТочка == КонечТочка то МаксимальноеРасстояние = ДлинаПути(Старт, ТекущаяСледующаяТочка)
    Если ТекущаяСледующаяТочка != пусто, то
      Добавляем ТекущаяСледующаяТочка в множество текущих точек   
Пока ТекущаяСледующаяТочка != пусто







